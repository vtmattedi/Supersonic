#include <WiFi.h>
#include <WiFiClient.h>
#include <ESPmDNS.h>
#include <C:\Users\Vity1\Documents\Arduino\libraries\DallasTemperature\DallasTemperature.h>
#include <C:\Users\Vity1\Documents\Arduino\libraries\Time-master\TimeLib.h>
#include <HTTPClient.h>
#include <WiFiUdp.h>
#include <ArduinoOTA.h>
#include <SPIFFS.h>
#include "FS.h"
#include <SPI.h>
#include <C:\Users\Vity1\Documents\PlatformIO\Projects\Estufa_WebPage\.pio\libdeps\esp32dev\AsyncTCP-esphome\src\AsyncTCP.h>
#include <C:\Users\Vity1\Documents\PlatformIO\Projects\Estufa_WebPage\.pio\libdeps\esp32dev\ESPAsyncWebServer-esphome\src\ESPAsyncWebServer.h>
#include <DNSServer.h>
#include "SD_MMC.h"
#define www_username "admin"
#define www_password "admin"
#define DNS_NAME "Estufa"

#define ONE_WIRE_BUS 16
#define TEMPERATURE_PRECISION 9
#define RELAY_PIN 13

#define HISTORY_SIZE 1000
#define DEBUGMODE
#define GET_VARIABLE_NAME(Variable) (#Variable)

float DS18Temp[HISTORY_SIZE];
int DS18Time[HISTORY_SIZE];
uint16_t DS18_CurrentIndex = 0;
int LastTime = 0;
int startup_time = 0;
int random_temp = 300; //delete this after using
float tolerance  = 0.5; // Will mantain temperature within this tolerance.
//Greenhouse Control Variables
#define MAX_STEPS 22
byte currentProg = 0;

//Flags
bool new_ramp = false;
bool new_step = false;
bool new_prog = false;
bool new_relay_state = false;

bool is_time_configured = false;

bool is_updating = false;
bool is_SPIFFSS_Mount = false, is_SD_Mount = false;
void SD_File_Writer(String, String, bool);
String normalizedDayMonth();
void StandardTesting();
String getCurrentProcess();
int oldM = 0;

struct DebugFlags
{
    bool web = true;
    bool ramp = false;
    bool temp = false;
    bool log = false;
};

struct HeatRamp
{
    String projectName;
    String csvFile = "/Logs/Noname.csv";
    String logFile = "/Logs/Noname.log";
    byte currentstep = 0;
    byte totalsteps = 0;
    float temperatureSteps[MAX_STEPS +1];
    float minuteSteps[MAX_STEPS + 1];
    unsigned int StepsTimes[MAX_STEPS +1];
    bool programStartTime = false;
    bool heatUp = false;
    bool heating = false;
    unsigned int startTime = 0;
    unsigned int startHeating = 0;
    unsigned int endTime = 0;
    //Prints the Heatramp Object
    void print()
    {
        String ramp = "";
        ramp += "Name: ";
        ramp += projectName;
        ramp += "\nTotal steps: ";
        ramp += totalsteps;
        ramp += "\nTemperature, Time, Step Time\n";
        for (size_t i = 0; i < totalsteps; i++)
        {
            ramp += temperatureSteps[i];
            ramp += ", ";
            ramp += minuteSteps[i];
            ramp += ", ";
            ramp += StepsTimes[i];
            ramp += ",\n";
        }
        ramp += "Log file: ";
        ramp += logFile;
        ramp += "\nStart: ";
        ramp += startTime;
        ramp += "\nProgram Start: ";
        ramp += programStartTime;
        ramp += "\nHeatUp: ";
        ramp += heatUp;

        Serial.println(ramp);
    }
    //Sets the Log Filename
    void startLogs()
    {
        generateCsv();
        generateLog();
    }
    void generateCsv()
    {
        if (!is_SD_Mount)
            return;
        String baseName = "/Logs/" + projectName;
        bool nameAvailable = false;
        u_int nextName = 1;
        if (!SD_MMC.exists(baseName + ".csv"))
        {
            csvFile = baseName + ".csv";
            //createLogFile(logFile);
            nameAvailable = true;
        }

        while (!nameAvailable)
        {
            String newName = baseName + "(" + nextName + ").csv";
            nextName++;
            if (!SD_MMC.exists(newName))
            {
                csvFile = newName;
                nameAvailable = true;
            }
        }

        Serial.print("Creating '");
        Serial.print(csvFile);
        Serial.println("'. Time, Temp, SetTemp, Relay, CurrentStep");
        SD_File_Writer(csvFile, "Time Stamp,Time, Temperature,Set Temperature, Relay Status, Current Step\n", true);
    }
    //Starts the Log file
    void generateLog()
    {
        if (!is_SD_Mount)
            return;
        String baseName = csvFile.substring(0, csvFile.lastIndexOf('.'));
        bool nameAvailable = false;
        u_int nextName = 1;
        baseName += "[";
        baseName += normalizedDayMonth();
        baseName += "]";
        if (!SD_MMC.exists(baseName + ".log"))
        {
            logFile = baseName + ".log";
            nameAvailable = true;
        }

        while (!nameAvailable)
        {
            String newName = baseName + "(" + nextName + ").csv";
            nextName++;
            if (!SD_MMC.exists(newName))
            {
                logFile = newName;
                nameAvailable = true;
            }
        }

        Serial.print("Creating '");
        Serial.print(logFile);
        Serial.println("'. Time, Temp, SetTemp, Relay, CurrentStep");
        SD_File_Writer(logFile, "Time,Temperature,Set Temperature, Relay Status, Current Step\n", true);
    }
    //Calculate the StepTimes array
    void calculateStepTimes()
    {
        Serial.println("Calculating StepTimes: ");
        for (size_t i = 0; i < totalsteps; i++)
        {
            StepsTimes[i] = startTime;
            for (size_t j = 0; j < i + 1; j++)
            {
                StepsTimes[i] += (int)(minuteSteps[j] * 60);
            }
            Serial.print("Step: ");
            Serial.print(i);
            Serial.print(" -> ");
            Serial.println(StepsTimes[i]);
        }
    }
    //logs the temperature and all the variables to a csv file associated to your projectname.
    void csv(float temperature, bool RelayStatus)
    {
        String Message = "";
        Message += now();
        Message += ",";
        Message += now() - startTime;
        Message += ",";
        Message += temperature;
        Message += ",";
        Message += temperatureSteps[currentstep];
        Message += ",";
        Message += RelayStatus;
        Message += ",";
        Message += currentstep + 1;
        Message += "\n";
        Serial.print(Message);
        SD_File_Writer(csvFile, Message, true);
    }
    void log(String message)
    {
        String _message ="[";
         _message += now() - startTime;
         _message += "] ";
        SD_File_Writer(logFile, _message, true);
    }
    //Resets the HeatRamp Object --not otimized
    void reset()
    {
        Serial.println("Reseting HeatRamp...");
        endTime = 0;
        currentstep = 0;
        projectName = "No Name";
        logFile = "/Logs/Noname.csv";
        programStartTime = false;
        startTime = 0;
        totalsteps = 0;
        running = false;
        finished = false;
        configured = false;
        for (size_t i = 0; i < MAX_STEPS +1; i++)
        {
            minuteSteps[i] = 0;
            temperatureSteps[i] = 0;
            StepsTimes[i] = 0;
        }

        return;
    }
    //Flags
    bool running = false;
    bool finished = false;
    bool configured = false;
};

#define MAX_CACHE_PAGES 5

struct HtmlCache
{
    String CachedPages[MAX_CACHE_PAGES];
    String Keys[MAX_CACHE_PAGES];

    void setup()
    {
        for (size_t i = 0; i < MAX_CACHE_PAGES; i++)
        {
            CachedPages[i] = "";
            Keys[i] = "";
        }
    }

    int Contains(String key)
    {
        for (size_t i = 0; i < MAX_CACHE_PAGES; i++)
        {
            if (key == Keys[i])
                return i;
        }
        return -1;
    }

    bool LoadPage(String key, String filename)
    {
        int index = getFreeSpace();
        if (index < 0 || index > MAX_CACHE_PAGES)
            return false;
        if (!is_SD_Mount)
            return false;
        if (!SD_MMC.exists(filename))
            return false;
        Keys[index] = key;
        File _file = SD_MMC.open(filename);
        CachedPages[index] = _file.readString();
        _file.close();
        return true;
    }
    
    bool LoadPage( bool blanck = false)
    {
          int index = getFreeSpace();
        if (index < 0 || index > MAX_CACHE_PAGES)
            return false;
        if (!blanck)
        return true;
        Keys[index] = "    ";
        CachedPages[index] = "   ";
        return true;
    }

    int getFreeSpace()
    {
        for (size_t i = 0; i < MAX_CACHE_PAGES; i++)
        {
            if (Keys[i] == "")
                return i;
        }
        return -1;
    }

    bool releasePage(String key)
    {
        int index = Contains(key);
        if (index < 0)
            return false;

        CachedPages[index] = "";
        Keys[index] = "";

        return true;
    }

    String getPagebyIndex(int index)
    {
        if (index > -1 && index < MAX_CACHE_PAGES)
            return CachedPages[index];
        else
            return "";
    }

    String getPagebyKey(String key)
    {
        return getPagebyIndex(Contains(key));
    }
};

HtmlCache Cache;
HeatRamp currentRamp;
HeatRamp lastRamp;

DebugFlags debug;

int nextStep = 0;

// Smart Mode > Waits for the temperature to get to the set value before counting the time.
bool smartMode_enabled = false;
bool smartMode_Active = false;
int smartModeTime = 0;

bool ended_flag = false;
int ended_time = 0;
int sample_rate_in_seconds = 5;

// Setup a oneWire instance to communicate with any OneWire devices (not just Maxim/Dallas temperature ICs)
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature DS18(&oneWire);

AsyncWebServer server(80);

class CaptiveRequestHandler : public AsyncWebHandler
{
public:
    CaptiveRequestHandler() {}
    virtual ~CaptiveRequestHandler() {}

    bool canHandle(AsyncWebServerRequest *request)
    {
        //request->addInterestingHeader("ANY");
        return true;
    }

    void handleRequest(AsyncWebServerRequest *request)
    {
        AsyncResponseStream *response = request->beginResponseStream("text/html");
        response->print("<!DOCTYPE html><html><head><title>Captive Portal</title></head><body>");
        response->print("<p>This is out captive portal front page.</p>");
        response->printf("<p>You were trying to reach: http://%s%s</p>", request->host().c_str(), request->url().c_str());
        response->printf("<p>Try opening <a href='http://%s'>this link</a> instead</p>", WiFi.softAPIP().toString().c_str());
        response->print("</body></html>");
        request->send(response);
    }
};

#define WIFI_AP_SSID "ESP32 Estufa"
#define WIFI_AP_PASSWORD "ESP32ESP32"
String WIFI_SSID = "MCarvalho", WIFI_PASSWORD = "salvador";

u_int LineCounter = 0;

String StateString()
{
    String msg = "";
    if (currentRamp.configured)
    {
        msg += "heat_ramp:";
        if(currentRamp.startTime ==0)
        msg+= "-1";
        else
        msg += currentRamp.startTime;
        msg += ',';
        for (int i = 0; i < currentRamp.totalsteps; i++)
        {
            msg += currentRamp.temperatureSteps[i];
            msg += " ";
            msg += currentRamp.minuteSteps[i];
            msg += ",";
        }
        msg += ':';
        msg += ended_time;
    }
    msg += ";new_prog:";
    msg += currentProg;
    msg += ";current_state: ";
    msg += currentRamp.running;
    msg += ";new_step:";
    msg += currentRamp.currentstep + 1;
    msg += ";relay_status:";
    msg += digitalRead(RELAY_PIN);
    msg += ';';
    msg += ";current_process:";
    msg += getCurrentProcess();
    msg += ';';
    return msg;
}

String getCurrentProcess()
{
    if (currentRamp.running)
    return "Working";
    else if (currentRamp.heating)
    return "Heating";
    else if (currentRamp.configured)
    return "Waiting to Start";
    else 
    return " Idle";
}

String saveConfigString()
{
    String msg = GET_VARIABLE_NAME(WIFI_SSID);
    msg += ':';
    msg += WIFI_SSID;
    msg += ';';
    msg = GET_VARIABLE_NAME(WIFI_PASSWORD);
    msg += ':';
    msg += WIFI_PASSWORD;
    msg += ';';

    return msg;
}

String getMIME(String filename)
{
    if (filename.endsWith(".htm"))
        return "text/html";
    else if (filename.endsWith(".html"))
        return "text/html";
    else if (filename.endsWith(".css"))
        return "text/css";
    else if (filename.endsWith(".js"))
        return "text/javascript";
    else if (filename.endsWith(".png"))
        return "image/png";
    else if (filename.endsWith(".gif"))
        return "image/gif";
    else if (filename.endsWith(".jpg"))
        return "image/jpeg";
    else if (filename.endsWith(".ico"))
        return "image/x-icon";
    else if (filename.endsWith(".xml"))
        return "text/xml";
    else if (filename.endsWith(".pdf"))
        return "application/x-pdf";
    else if (filename.endsWith(".zip"))
        return "application/x-zip";
    else if (filename.endsWith(".gz"))
        return "application/x-gzip";
    else if (filename.endsWith(".csv"))
        return "text/csv";
    else if (filename.endsWith(".log"))
        return "text/log";
    return "text/plain";
}

String normalizedDayMonth()
{

    if (!is_time_configured)
        return "";
    String msg = "";
    if (day() < 10)
        msg += '0';
    msg += day();
    msg += '-';
    if (month() < 10)
        msg += '0';
    msg += month();
    return msg;
}

void GeneralLog(String message)
{
    String _msg = "[";
    if (is_time_configured)
        _msg += now();
    else
        _msg += "clock not synced";
    _msg += "]>>>>>";
    _msg += message;
    _msg += "\n";
    SD_File_Writer("/Logs/General.log", _msg, true);
}

void SPIFFS_File_Writer(String Filename, String Content, bool append = false)
{
    if (!is_SPIFFSS_Mount)
    {
        Serial.println("SPIFFS not Mount");
        return;
    }
    if (map(SPIFFS.usedBytes(), 0, SPIFFS.totalBytes(), 0, 100) > 90)
    {
        Serial.println("SPIFFS over 90%");
        return;
    }

    if (Filename[0] != '/')
        Filename = '/' + Filename;

    File _file;
    if (append)
        _file = SPIFFS.open(Filename, "a");
    else
    {
        if (SPIFFS.exists(Filename))
            SPIFFS.remove(Filename);
        _file = SPIFFS.open(Filename, "w");
    }
    _file.print(Content);
    _file.flush();
    _file.close();
}

void SD_File_Writer(String Filename, String Content, bool append = false)
{
    if (!is_SD_Mount)
    {
        Serial.println("SPIFFS not Mount");
        return;
    }

    if (Filename[0] != '/')
        Filename = '/' + Filename;

    File _file;
    if (append)
        _file = SD_MMC.open(Filename, "a");
    else
    {
        if (SD_MMC.exists(Filename))
            SD_MMC.remove(Filename);
        _file = SD_MMC.open(Filename, "w");
    }
    _file.print(Content);
    _file.flush();
    _file.close();
}

#pragma region HeatRamp functions

//Logs current status --Still in debug
void logramp(HeatRamp hr, float temperature, bool RelayStatus, bool changingStep = false)
{
    String Message = "";
    if (!changingStep)
    {
        Message += "Time: ";
        Message += now();
        Message += " Temp: ";
        Message += temperature;
        Message += " Set Temp: ";
        Message += hr.temperatureSteps[hr.currentstep];
        Message += " step: ";
        Message += hr.currentstep + 1;
        Message += " Relay: ";
        Message += RelayStatus;
        Message += "\n";
    }
    else
    {
        Message += "Time: ";
        Message += now();
        Message += " . New Step: ";
        Message += hr.currentstep + 1;
        Message += ".\n";
    }
    SD_File_Writer(hr.logFile, Message, true);
}

#pragma endregion

void SPIFFS_File_Mover(String Origin_Filename, String Target_Filename)
{
    if (!is_SPIFFSS_Mount)
    {
        Serial.println("SPIFFS not Mount");
        return;
    }
    if (Origin_Filename[0] != '/')
        Origin_Filename = '/' + Origin_Filename;
    if (Target_Filename[0] != '/')
        Target_Filename = '/' + Target_Filename;

    if (!SPIFFS.exists(Origin_Filename))
    {
        Serial.print("File: '");
        Serial.print(Origin_Filename);
        Serial.println("' not found.");
        return;
    }

    File _file = SPIFFS.open(Target_Filename, "w");
    _file.print(SPIFFS.open(Origin_Filename).readString());
    _file.flush();
    _file.close();
    SPIFFS.remove(Origin_Filename);
}

void resetFlags() // Reset the flags of new data to be sent to HTTP front end
{
    new_ramp = false;
    new_step = false;
    new_prog = false;
    new_relay_state = false;
    ended_flag = false;
}

void printArray(int array[])
{
    Serial.print(sizeof(array));
    Serial.print(":");
    for (size_t i = 0; i < sizeof(array); i++)
    {
        Serial.print(" ");
        Serial.print(array[i]);
        Serial.print(".");
    }
    Serial.println();
}

#pragma region Ramp Start - End

void StartRamp()
{
    String msg = "Starting new Ramp: ";
    msg += currentRamp.projectName;
    msg += "\nNow: ";
    msg += now();
    msg += "\nTimes: [";
    for (size_t i = 0; i < currentRamp.totalsteps; i++)
    {
        msg += currentRamp.minuteSteps[i];
        msg += ',';
    }
    msg += "]\nTemps: [";
    for (size_t i = 0; i < currentRamp.totalsteps; i++)
    {
        msg += currentRamp.temperatureSteps[i];
        msg += ',';
    }
    msg += "]\nSteps: ";
    msg += currentRamp.totalsteps;
    msg += "\n";
    currentRamp.log(msg);
    GeneralLog("Starting Ramp: " + currentRamp.projectName);
    currentRamp.running = true;
    ended_flag = false;
    currentRamp.currentstep = 0;
    currentRamp.startTime = now() + 1;
    currentRamp.calculateStepTimes();
    Serial.println("======= Starting Heat Ramp =======");
    currentRamp.print();
    oldM = millis();
}

void resetRamp()
{
    currentProg = 0;
    nextStep = 0;
    ended_time = 0;
    ended_flag = false;
}

void EndRamp()
{
    currentRamp.running = false;
    currentRamp.finished = true;
    ended_flag = true;
    currentRamp.endTime = now();
    GeneralLog("Ending Ramp: " + currentRamp.projectName);
    Serial.println("======= Ending Heat Ramp =======");
}

#pragma endregion

String listLogFiles()
{
    if (!is_SD_Mount)
        return "error:SD card not found;";

    String msg = "files:";

    File root = SD_MMC.open("/Logs");
    File file = root.openNextFile();

    while (file)
    {
        String s = file.name();
        s.replace(' ', 'Â');
        msg += s;
        msg += ' ';
        msg += (float)file.size() / 1024;
        msg += ',';
        file = root.openNextFile();
    }

    msg += ';';
    return msg;
}

void handleRequestHist(AsyncWebServerRequest *request)
{
    int a = millis();
    if (!is_time_configured)
    {
        request->send(200, "txt/plain", "set_time;");
        return;
    }
    bool done = true;
    String msg = "temp_history:";
    for (int i = 0; done; i++)
    {
        if (DS18Temp[i] == 0 && DS18Time[i] == 0)
            done = false;
        else if (i + 1 >= HISTORY_SIZE)
            done = false;
        else
        {
            msg += DS18Time[i];
            msg += " ";
            msg += DS18Temp[i];
            msg += ",";
        }
    }
    msg += ';';
    msg += "new_temp:";
    int x = DS18_CurrentIndex - 1;
    if (x < 0)
        x = HISTORY_SIZE - 1;
    msg += DS18Time[x];
    msg += " ";
    msg += DS18Temp[x];
    msg += ";";

    msg += StateString();

    request->send(200, "txt/plain", msg);
    Serial.print(millis() - a);
    Serial.println("ms.");
    return;
}

void handleRequestUpdate(AsyncWebServerRequest *request)
{
    String message = "new_temp:";
    int x = DS18_CurrentIndex - 1;
    if (x < 0)
        x = HISTORY_SIZE - 1;
    message += DS18Time[x];
    message += " ";
    message += DS18Temp[x];
    message += ";";

    if (new_ramp)
    {
        message += "heat_ramp:";
        if (currentRamp.startTime == 0)
            message += "-1";
        else
            message += currentRamp.startTime;
        message += ',';

        for (int i = 0; i < currentRamp.totalsteps; i++)
        {
            message += currentRamp.temperatureSteps[i];
            message += " ";
            message += currentRamp.minuteSteps[i];
            message += ",";
        }
        message += ':';
        message += ended_time;
        message += ';';
    }
    if (new_prog)
    {
        message += "new_prog:";
        message += currentProg;
        message += ';';
    }
    if (new_step)
    {
        message += "new_step:";
        message += currentRamp.currentstep + 1;
        message += ';';
    }
    if (new_relay_state)
    {
        message += "relay_status:";
        message += digitalRead(RELAY_PIN);
        message += ';';
    }
    if (ended_flag)
    {
        message += "ramp_end:";
        message += currentRamp.endTime;
        message += ';';
    }
   
     if (!is_time_configured)
     {
        message += "st_time";
    }
    request->send(200, "text/plain", message);
    // Serial.println(message);
}

void handleNewRamp(AsyncWebServerRequest *request)
{
    if (!currentRamp.running)
    {
        currentRamp.totalsteps = atoi(request->arg((size_t)0).c_str());
        int j = 0;
        for (size_t i = 1; i < request->args(); i++)
        {
            if (i + 1 < request->args())
            {
                if (request->arg(i) != "" && request->arg(i + 1) != "")
                {
                    currentRamp.temperatureSteps[j] = atof(request->arg(i).c_str());
                    currentRamp.minuteSteps[j] = atof(request->arg(i + 1).c_str());
                    j++;
                }
                else
                    currentRamp.totalsteps--;
            }
            i++;
        }
        currentRamp.currentstep = 0;
        String start = request->arg("_start");
        if (request->arg("heatup") == "on")
            currentRamp.heatUp = true;
        currentRamp.projectName = request->arg("pname");
        currentRamp.startLogs();
        currentRamp.print();
         currentRamp.configured = true;
        if (start == "on")
        {
            StartRamp();
        }
        new_ramp = true;
       
    }
    request->send(200, "text/html", "<html><script>window.location.assign(\"/\")</script></html>");
}

void SendLargeFiles(AsyncWebServerRequest *request, File File)
{
    //request->sendChunked(200,getMIME( File.name()), File.readString().c_str());
    Serial.print("Sending Large File: ");
    Serial.println(File.name());
    AsyncWebServerResponse *response = request->beginResponse(SD_MMC, File.path(), getMIME(File.name()));
    request->send(response);
    return;
}
void getTime()
{
    Serial.println("Syncing Time Online");
    HTTPClient http;
    http.begin("http://worldtimeapi.org/api/timezone/America/Bahia.txt"); //HTTP
    int httpCode = http.GET();
    // httpCode will be negative on error
    if (httpCode > 0)
    {
        // HTTP header has been send and Server response header has been handled
        // file found at server
        if (httpCode == HTTP_CODE_OK)
        {
            Serial.printf("[HTTP] OK... code: %d\n", httpCode);
            String payload = http.getString();
            char str[payload.length() + 1];
            strcpy(str, payload.c_str());
            char *pch;
            pch = strtok(str, ":\n");
            int i = 0;
            //  int raw_offset = 0;
            while (pch != NULL)
            {

                i++;
                if (i == 23)
                {
                    //    raw_offset = atoi(pch);
                }
                if (i == 27)
                {
                    setTime(atoi(pch));
                }
                //printf("%d: %s\n", i, pch);
                pch = strtok(NULL, ":\n");
            }
            is_time_configured = true;
            String msg ="Time Synced ";
            msg+=  millis();
            msg+=  "ms from boot.";
            GeneralLog(msg);
            StandardTesting();
        }
        else
        {
            Serial.printf("[HTTP] Error code: %d\n", httpCode);
        }
    }
    else
    {
        Serial.printf("[HTTP] GET... failed, error: %s\n", http.errorToString(httpCode).c_str());
    }
    http.end();

    startup_time = now();
}

void startHeating()
{
    Serial.println("Start Heating up to: ");
    Serial.print(currentRamp.temperatureSteps[0]);
    currentRamp.heating = true;
    currentRamp.startTime = now(); 
}

String getPage2()
{
    return
        //##$$CommonScript.js
var count = 0;
var CircCount = 0;
const HandledCircles = [];
const xmlHttp = new XMLHttpRequest();
var getDataTimer = setInterval(RequestData, 5000);
var getDataTimer = setInterval(RequestData("/reqstate"), 15000);
var updateTimer = setInterval(setTime, 1000);
var dns_name = window.location.hostname;
const GraphOptions = new GraphOptionsCreator();
google.charts.load('current', { 'packages': ['corechart'] });
google.charts.setOnLoadCallback(drawChart);

var am_i_offline = false;

const CurrentRamp = new CurrentRampCreator();
const State = new StateCreator();

function CurrentRampCreator() {
    this.temp = [];
    this.times = [];
    this.stepsTimeStamps = [];
    this.start = 0;
    this.end = 0;
    this.remaningTime = 0;
    this.finished = false;
    this.computedEnd = 0;
    this.configured = false;


}

function StateCreator() {
    this.Temperature = 0;
    this.CurrentStep = 0;
    this.MaxSteps = 0;
    this.Progress = 0;
    this.isRunning = false;
    this.Paused = false;
    this.Finished = false;
    this.relay_status = false;
    this.WorkerState = '';
    this.update = function () { updateRampState() };

}
function GraphOptionsCreator() {
    this.DrawProgramedRamp = true;
    this.RampOption = 'function';
    this.GraphSize = -1;
    this.DataTable = undefined;
    this.ShowFuture = true;
    this.holdGraph = false;
}
function CirclePropertyHandler(nameOfCircle) {
    this.id = nameOfCircle;
    this.NeedToMap = false;
    this.PercentMap = {
        'min': 0,
        'max': 100,
        'new_min': 0,
        'new_max': 100
    };
    this.RainbowBar = false;
    this.RainbowNumber = false;
    this.Rainbow = { 'min': '#000000', 'max': '#FFFFFF' };
    this.SetNew = function (value) {
        _val = parseInt(value);
        var _color = undefined;
        var _numberColor = undefined;
        var _valueText = undefined;
        if (_val < 0 || _val > 100) {
            console.log('cant parse new value.', this.id, value);
        }
        if (this.NeedToMap) {
            if (Number.isNaN(this.PercentMap.min) || Number.isNaN(this.PercentMap.max) || Number.isNaN(this.PercentMap.new_min) || Number.isNaN(this.PercentMap.new_max)) {
                this.NeedToMap = false;
                console.log('NaN detected in Mapping ' + this.id + ' disabling map functionality');
                return;
            }
            _val = mapN(_val, this.PercentMap.min, this.PercentMap.max, this.PercentMap.new_min, this.PercentMap.new_max);
            _valueText = value;
        }
        if (this.RainbowBar) {
            //TODO get raibow color
            _color = "#FFFFF0";
        }
        if (this.RainbowNumber) {
            //TODO get raibow color
            _numberColor = "#FFFFF0";
        }

        setnew(this.id, _val, _valueText, _color, _numberColor);
    };

}

function test() {
    // var x = "new_temp" + (Date.now() / 1000) + " 23.81;heat_ramp:-1,10.00 20.00,20.00 20.00,40.00 10.00,20.00 10.00,15.00 15.00,;new_step:1; address:;ramp_start:1622612683;"

    // ParseNewData(x);

    saveData();
}

function setcircle(CircId, value) {

    for (var i = 0; i < HandledCircles.length; i++) {
        if (HandledCircles[i].id == CircId) {
            HandledCircles[i].SetNew(value);
            return;
        }
    }
}

function updateButtonState(buttonState) {
    var name = buttonState.id;
    document.getElementById(name + '_text').innerHTML = buttonState.state;
    document.getElementById(name).className = 'button button' + buttonState.state;
    document.getElementById(name + '_tooltip').hidden = true;
    if (typeof buttonState.enabled !== 'undefined') {

        if (buttonState.enabled) {
            document.getElementById(buttonState.id).removeAttribute("disabled");
        }
        else
            document.getElementById(buttonState.id).setAttribute("disabled", "disabled");
    }
    if (typeof buttonState.tooltip !== 'undefined') {

        if (buttonState.tooltip.enabled) {
            document.getElementById(name + '_tooltip').hidden = false;
        }
        else
            document.getElementById(name + '_tooltip').hidden = true;
        document.getElementById(name + '_tooltip').innerHTML = buttonState.tooltip.text;
    }

}

function newHeatRamp(args, end) {

    CurrentRamp.finished = false;
    var _args = args.split(',');
    CurrentRamp.start = parseInt(_args[0]);
    var _newtemps = [];
    var _newtimes = [];
    var _end = 0;
    var c_end = 0;

    if (typeof end !== 'undefined')
    _end  = parseInt(end);

    for (var i = 1; i < _args.length; i++) {
        var newSet = _args[i].split(' ');
        if (!isNaN(parseFloat(newSet[0]) && !isNaN(parseFloat(newSet[1])))) {
            _newtemps[i - 1] = parseFloat(newSet[0]);
            _newtimes[i - 1] = parseFloat(newSet[1]);
            c_end += parseFloat(newSet[1]) * 60;
        }
    }
    CurrentRamp.temp = _newtemps;
    State.MaxSteps = _newtemps.length;
    CurrentRamp.times = _newtimes;
    CurrentRamp.computedEnd = c_end;
    CurrentRamp.end = _end;
    CurrentRamp.stepsTimeStamps = [];
   
    if (CurrentRamp.end >0)
    EndRampRoutine();
    else if (CurrentRamp.start > 0) {
        StartRampRoutine();
    }
    else  {
        NewRampRoutine();
    }

    drawChart();
}

function SetStopButton(state, enabled) {
    var newBtnState =
    {
        id: undefined,
        state: undefined,
        tooltip: undefined,
        enabled: true
    }

    if (typeof enabled !== 'undefined') {
        newBtnState.enabled = enabled;
        if (!enabled)
            newBtnState.tooltip = { enabled: true, text: 'Load a heat ramp to be able to start it' }
    }


    newBtnState.id = 'btnStop'
    newBtnState.state = state;
    updateButtonState(newBtnState);


}

function SetNewRampButton(enabled) {
    var newBtnState =
    {
        id: undefined,
        state: undefined,
        tooltip: undefined,
        enabled: true
    }

    if (typeof enabled !== 'undefined') {
        newBtnState.enabled = enabled;
        if (!enabled)
            newBtnState.tooltip = { enabled: true, text: 'Stop or finish current procedure before loading a new ramp' }
    }


    newBtnState.id = 'btnNewRamp'
    newBtnState.state = 'New Ramp';
    updateButtonState(newBtnState);


}


function updateRampState() {

    updateRemTime()
    document.getElementById('currentStepsLabel').innerText = State.CurrentStep + '/' + State.MaxSteps;
}

function updateRemTime() {
    var _remTime = 0;
    if (CurrentRamp.start <= 0) {
        _remtime = new Date(State.computedEnd * 1000);
    }
    else   if (State.isRunning){
        _remtime = new Date(CurrentRamp.start * 1000 + parseInt(State.computedEnd) * 1000 - Date.now()); 
        document.getElementById('remainingTimeLabel').innerHTML = formatDate(_remTime);
    } 

}

window.onload = function () {

   
    generateCircle('circle_1', 'Temperature', 0, 'Temp', '#d4ebd3', '#ff3f38', '#964845', '&degC', 'map 10 90 1 99');
    generateCircle('circle_2', 'Progress', 0, 'Prog', '#f79e9e', '#60bd6b', '#ad8053', '%', 'rainbow #FF0000 #00FF00');
    ResetRoutine();
    var data = new google.visualization.DataTable;
    data.addColumn('date', 'Time');
    data.addColumn('number', 'Temperature');
    GraphOptions.DataTable = data;
    document.getElementById('DrawHeatRampSlider').checked = GraphOptions.DrawProgramedRamp;
    document.getElementById('TimeSpanSelect').value = GraphOptions.GraphSize;
    document.getElementById('ShowFutureSlider').checked = GraphOptions.ShowFuture;
    setTime();
    RequestData('reqhist');
    am_i_offline =  isOnline();
};
function setTime() {

    //var x = "new_temp:" + Date.now()/1000 + " 20;";
    //ParseNewData(x);

    var date = new Date(Date.now());
    document.getElementById('timeLabel').innerHTML = formatDate(date);
    updateRemTime();

}

function formatDate(date) {
    if (typeof date === 'object') {
        try {

            var str = '';
            if (date.getHours() < 10)
                str += '0';
            str += date.getHours();
            if (date.getSeconds() % 2 == 0)
                str += ':';
            else
                str += ' ';
            if (date.getMinutes() < 10)
                str += '0'
            str += date.getMinutes();

            return str;
        }

        catch (error) { console.log(error);
            return null; }
    }
  
}

//Request Data from backend and add to chart
function RequestData(whichdata) {
    if (typeof whichdata !== 'string')
        httpGetAsync("requpdate", ParseNewData);
    else
        httpGetAsync(whichdata, ParseNewData);
}

function ParseNewData(incomeString) {
    try {
        var new_routine = 'none';
        var requestStateUpdate = false;
        for (var i = 0; i < incomeString.split(';').length; i++) {
            var _args = incomeString.split(';')[i].split(':');
            if (_args[0] == 'heat_ramp') {
                newHeatRamp(_args[1],_args[2]);
            }
            if (_args[0] == 'new_temp') {

                var new_temp = _args[1].split(' ')[1];
                State.Temperature = parseInt(new_temp);
                setcircle('Temp', new_temp.substr(0, 4));
                addData(GraphOptions.DataTable, _args[1]);
            }
            if (_args[0] == 'raw') {
                handleRaw(_args[1]);
            }
            if (_args[0] == 'new_prog') {
                var new_prog = parseInt(_args[1]);
                if (!isNaN(new_prog)) {
                    State.percent = new_prog;
                    setcircle('Prog', new_prog);
                }
            }
            if (_args[0] == 'new_step') {
                var new_step = parseInt(_args[1]);
                State.CurrentStep = new_step;
                requestStateUpdate = true;
                if (new_step -1 >= 0)
                CurrentRamp.stepsTimeStamps[new_step -1] = Date.now()/1000;
            }
            if (_args[0] == 'relay_status') {
                State.relay_status = (_args[1] == true);
                requestStateUpdate = true;
            }
            if (_args[0] == 'temp_history') {
                console.log(incomeString);
                addData(GraphOptions.DataTable, _args[1]);
            }
            if (_args[0] == 'current_state') {
                State.isRunning = (_args[1] == true);
                if(State.isRunning && !CurrentRamp.configured)
                RequestData("/heatramp");
                requestStateUpdate = true;
            }
            if (_args[0] == 'ramp_start') {
                CurrentRamp.start = parseInt(_args[1]);
                if (CurrentRamp.start > 0) {
                    StartRampRoutine();
                    new_routine = 'start';
                }
            }
            if (_args[0] == 'ramp_end') {
                var end = parseInt(_args[1]);
                if (end > 0) {
                    State.isRunning = false;
                    currentRamp.end = end;
                    new_routine = 'end';
                }
            }
            if (_args[0] == 'ramp_reset') {
                new_routine = 'reset';

            }
            if (_args[0] == 'set_time') {
                sendTime();
               
            }
            if (_args[0] == 'set_time-sucess')
            {
                alert('Time Synced!');
            }
            if (_args[0] == 'error')
            {
                alert(_args[1]);
            }
            if (_args[0] == 'curr_process')
            {
                State.WorkerState = _args[1];
                State.update();
            }
        }

        if (new_routine !== 'none') {
            if (new_routine === 'start')
                StartRampRoutine();
            if (new_routine === 'end')
                EndRampRoutine();
            if (new_routine === 'reset')
                ResetRoutine();
        }

        if (requestStateUpdate) {
            State.update();
        }

    }


    catch (err) {
        console.log(err);
    }
}

function handleRaw(args) {
    var commands = args.split(',');
    for (var command in commands) {
    }
}

function httpGetAsync(theUrl, callback) {
    xmlHttp.onreadystatechange = function () {
        if (xmlHttp.readyState == 4 && xmlHttp.status == 200)
            callback(xmlHttp.responseText);
    }
    xmlHttp.open("GET", theUrl, true); // true for asynchronous
    xmlHttp.send();
}
//Change the current HTML Page
function go(where) {
    window.location.assign("/" + where);
}

function manualStop() {

    confirm("Are you sure you want to stop the current running process?");
    var xmlHttp = new XMLHttpRequest();
    xmlHttp.onreadystatechange = function () {
        if (xmlHttp.readyState == 4 && xmlHttp.status == 200)
            rld(xmlHttp.responseText);
    }
    xmlHttp.open("POST", '/pause', true); // true for asynchronous
    xmlHttp.send();
}

function rld(dummy) {
    document.location.reload();
}

function genRampGraph(data) {
    var _currRampTime = CurrentRamp.start * 1000;
    if (_currRampTime <= 1)
        _currRampTime = Date.now();

    for (var i = 0; i < CurrentRamp.temp.length; i++) {
        for (var j = 1; j < 101; j++) {
            data.addRow([new Date(_currRampTime + ((j / 100) * 60 * 1000 * CurrentRamp.times[i])), CurrentRamp.temp[i]]);
        }
        var newtime = _currRampTime + 60 * 1000 * CurrentRamp.times[i];
        _currRampTime = newtime;
    }
}

function drawChart() {

    if (GraphOptions.holdGraph)
        return;

    //Create a separated datatable then join 
    var data = new google.visualization.DataTable();
    data.addColumn('date', 'Time');
    data.addColumn('number', 'Set Temperature');

    genRampGraph(data);


    //nowMarker = new google.visualization.DataTable();
    //nowMarker.addColumn('date', 'Time');
    //nowMarker.addColumn('number', 'Set Temperature');
    //nowMarker.addRow([new Date(Date.now()), State.Temperature]);
    //var semiData = google.visualization.data.join(GraphOptions.DataTable, data, 'full', [[0, 0]], [1], [1]);
    //var finalData = google.visualization.data.join(semiData, nowMarker, 'full', [[0, 0]], [1, 2], [1]);
    var finalData = google.visualization.data.join(GraphOptions.DataTable, data, 'full', [[0, 0]], [1], [1]);
    var date_formatter = new google.visualization.DateFormat({
        pattern: "HH:mm:ss"
    });
    date_formatter.format(finalData, 0);

    var dataview = new google.visualization.DataView(finalData);

    if (!GraphOptions.DrawProgramedRamp) {
        dataview.setColumns([0, 1]);
    }
    else
        dataview.setColumns([0, 1, 2]);
    if (GraphOptions.GraphSize > 0)
        dataview.setRows(dataview.getFilteredRows([{ column: 0, minValue: new Date(Date.now() - 60 * 1000 * GraphOptions.GraphSize) }]));
    if (!GraphOptions.ShowFuture)
        dataview.setRows(dataview.getFilteredRows([{ column: 0, maxValue: new Date(Date.now()) }]));


    var options = {
        //tooltip: {isHtml: true, trigger: 'selection'},
        title: 'Live Data',
        backgroundColor: '#F0FFF0',
        interpolateNulls: true,
        titleTextStyle: { textAlign: 'center', justify: 'center', fontName: 'Arial', fontSize: '30', bold: 'true' },
        legend: 'none',
        rampType: GraphOptions.RampOption, animation: { startup: true, easing: 'in' },
        hAxis: { title: 'Time', format: 'HH:mm' },
        colors: ['red', 'darkred', 'darkgreen'],
        vAxes: {
            0: {
                logScale: false, gridlines: { count: 5 }, title: 'Temp(\xB0C)', titleTextStyle: {
                    color: 'red',
                    fontName: 'Arial',
                    fontSize: '30'
                }
            },
            1: {
                logScale: false, maxValue: 100, minValue: 50, gridlines: { count: 10 }, title: 'Humidity(%)', fontName: 'Arial', titleTextStyle: {
                    color: 'blue',
                    fontName: 'Arial',
                    fontSize: '25'
                }
            }
        },
        series: {
            0: { targetAxisIndex: 0 },
            1: { targetAxisIndex: 0 },
        },
        explorer: {
            keepInBounds: true,
            maxZoomIn: 4.0,
            maxZoomOut: 2.0
        },
    };

    var chart = new google.visualization.LineChart(document.getElementById('ramp_chart'));
    chart.draw(dataview, options);

}

function addData(_DataTable, _newData) {
    try {
        var data = _newData.split(',');
        if (typeof data === 'undefined')
            return;

        for (var i = 0; i < data.length; i++) {
            var data2 = data[i].split(' ');
            if (data2[0] == 0 && data2[1] == 0);
            else {
                _DataTable.addRow([new Date(parseInt(data2[0]) * 1000), parseFloat(data2[1])]);
                if (_DataTable.getNumberOfRows() > 5000) {
                    _DataTable.removeRow(0);
                }
            }
        }

        drawChart();

    } catch (e) {
        console.log(e);
    }
}

function isOnline() {
    return window.navigator.onLine;
}

function generateCircle(div, _title, _initialPercent, _id, _bgcolor, _color, _numbercolor, _sign, args) {
    if (typeof div === 'object')
        div.innerHTML = createCircle(_title, _initialPercent, _id, _bgcolor, _color, _numbercolor, _sign);
    else {
        document.getElementById(div).innerHTML = createCircle(_title, _initialPercent, _id, _bgcolor, _color, _numbercolor, _sign);
    }

    var _property = new CirclePropertyHandler(_id);

    if (typeof args !== 'undefined') {
        _args = args.split(',');


        for (var i = 0; i < _args.length; i++) {
            _args2 = _args[i].split(' ');
            if (_args2[0] == 'map') {
                _property.NeedToMap = true;
                _property.PercentMap.min = parseInt(_args2[1]);
                _property.PercentMap.max = parseInt(_args2[2]);
                _property.PercentMap.new_min = parseInt(_args2[3]);
                _property.PercentMap.new_max = parseInt(_args2[4]);
            }
            else if (_args2[0] == 'rainbow') {
                _property.RainbowBar = true;
                _property.RainbowTitle = true;
                _property.Rainbow.min = _args2[1];
                _property.Rainbow.max = _args2[2];
            }
        }
    }

    HandledCircles.push(_property);
}
function createCircle(_title, _percent, _Id, _bgcolor, _color, _numbercolor, _sign) {
    if (typeof _title === 'undefined') {
        _title = null;
    }
    if (typeof _percent === 'undefined') {
        _percent = 0;
    }
    if (typeof _Id === 'undefined') {
        _Id = 'newId';

    }
    if (typeof _bgcolor === 'undefined') {
        _bgcolor = "#d4ebd3";
    }
    if (typeof _color === 'undefined') {
        _color = "darkred";
    }
    if (typeof _numbercolor === 'undefined') {
        _numbercolor = "#5f6362";
    }
    if (typeof _sign === 'undefined') {
        _sign = '%';
    }

    var percent = 440 * _percent / 100;
    percent = 440 - percent;
    var rtr = `
<div class="box">
<div class="Pbar">
<svg>
<circle style="stroke:` + _bgcolor + `;"cx ="70" cy="70" r="70"> </circle>
<circle class="c` + CircCount + `" id="` + _Id + `" cx="70" cy="70" r="70">
<style>
.box .Pbar .c`+ CircCount + ` {
 stroke:`+ _color + `;
 stroke-dasharray: 440;
 stroke-dashoffset: `+ percent + `;
 animation: mymove`+ CircCount + ` 2s ease-in;
 animation-iteration-count: 1;
}
@keyframes mymove`+ CircCount + `{
    from {stroke-dashoffset: 440;}
    to {stroke-dashoffset:` + percent + `;}
}</style>
</circle>
</svg>
<div class="prog" style="color:`+ _numbercolor + `;"> <h2 id="` + _Id + "N" + `"> ` + _percent + ` </h2><span>` + _sign + `</span></div></div><h2 class="legend">` + _title + `</h2>
</div>`;

    CircCount++;
    return rtr;
}
function setnew(_id, _newPercent, _newNumber, _color, _titleColor) {
    var _idN = _id + "N";
    if (typeof _color !== 'undefined') {
        document.getElementById(_id).style.color = _color;
    }
    if (typeof _titleColor !== 'undefined') {
        document.getElementById(_idN).style.color = _titleColor;
    }
    if (typeof _newNumber === 'undefined')
        document.getElementById(_idN).innerHTML = _newPercent;
    else
        document.getElementById(_idN).innerHTML = _newNumber;

    var _newoffset = 440 - (440 * _newPercent / 100);
    var _foward = true;
    if (_newoffset > parseInt(getComputedStyle(document.getElementById(_id)).strokeDashoffset, 10))
        _foward = false;

    //            console.log(parseInt(getComputedStyle(document.getElementById(_id)).strokeDashoffset, 10), _newoffset, _newPercent, _newNumber, _foward)
    
    if (!document.hidden)
    animateRoute(document.getElementById(_id), parseInt(getComputedStyle(document.getElementById(_id)).strokeDashoffset, 10), _newoffset, _foward);
}
function animateRoute(_id, _start, _end, _foward) {
    if (_foward) {
        _start -= 1;
        if (_start <= _end) {
            _start = _end;
            _id.style.strokeDashoffset = _start;
        }
        else {
            _id.style.strokeDashoffset = _start;
            setTimeout(function () { animateRoute(_id, _start, _end, true); }, 10);
        }
    }
    else {
        _start += 1;
        if (_start >= _end) {
            _start = _end;
            _id.style.strokeDashoffset = _start;
        }
        else {
            _id.style.strokeDashoffset = _start;
            setTimeout(function () { animateRoute(_id, _start, _end, false); }, 10);
        }
    }

}
function mapN(value, in_min, in_max, out_min, out_max) {
    if (value > out_max)
        return out_max;
    if (value < out_min)
        return out_min;
    return (value - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}
function changeDrawHeatRamp(slider) {
    GraphOptions.DrawProgramedRamp = slider.checked;
    drawChart();
}
function changeTimeSpan(object) {
    GraphOptions.GraphSize = parseInt(object.value);
    drawChart();
}
function changeShowFuture(object) {
    GraphOptions.ShowFuture = object.checked;
    drawChart();
}
function changeGraphMode(object) {
    GraphOptions.RampOption = object.value;
    drawChart();
}

function updateCurrentState() {

    document.getElementById("stateLabel").innerHTML = State.WorkerState;
    document.getElementById("stateLabel").className = 'stateLabel ' + State.WorkerState.trim();

    if (State.WorkerState == 'No Ramp Loaded!') {
        document.getElementById('WorkingState').style.display = 'none';
    }
    else {
        document.getElementById('WorkingState').style.display = 'flex';
    }

}

function NewRampRoutine(silent) {
    SetStopButton('Start');
    document.getElementById('WorkingState').style.display = 'flex';
    var _remTime = new Date(State._end * 1000);
    document.getElementById('remainingTimeLabel').innerText = _remTime.getTime() / 60000;

    document.getElementById('currentStepsLabel').innerText = '0/' + State.MaxSteps;
    if (silent != true)
        alert('New ramp loaded!');


}

function StartRampRoutine(silent) {
    document.getElementById('WorkingState').style.display = 'flex';
    SetNewRampButton(false);
    SetStopButton("Stop");
    State.isRunning = true;
    var end =0;
    for (var i = 0 ; i < State.MaxSteps;i++) 
    {
        end = end + CurrentRamp.times[i];
    }

    updateRemTime

    if (silent != true)
    alert("Ramp Started");

}

function PauseRampRoutine(params) {

}

function EndRampRoutine(silent) {
    SetStopButton('Start', false);
    SetNewRampButton(true);
    State.Finished = true;
    setcircle('Prog', 100);
   
    if (silent != true)
    alert('This Ramp has finished');

    saveData();

}

function saveData() {

    if (confirm('Do you want to download this last ramp?')) {
        var _start = CurrentRamp.start;
        var text = "[Heat Ramp] [csv] [unixtimestamp in m]\n";
        text += "start = ";
        text += _start;
        text += ", Heat Ramp = {temp: ";
        text += CurrentRamp.temp;
        text += "} {time: ";
        text += CurrentRamp.times;
        text += "}\r\n";
        text += "Temperature, time, delta time\r\n";
        text += "======== Starting step: ";
        text +=  1;
        text += ". Set Tempereture: ";
        text += CurrentRamp.temp[0];
        text += "\u00B0C for ";
        text += CurrentRamp.times[0];
        text += " minutes\r\n";
        var _step = 1;
        var stepFlag = true;
        if (CurrentRamp.stepsTimeStamps.length < 1)
        stepFlag = false;


        var endFlag = true;
        if (CurrentRamp.end <= 0)
        endFlag = false;

        for (var i = 0; i < GraphOptions.DataTable.getNumberOfRows(); i++) {
            var delta = GraphOptions.DataTable.getValue(i, 0).getTime() / 1000 - _start;

            if (delta >= 0) {
                if (GraphOptions.DataTable.getValue(i, 0).getTime() / 1000 >= CurrentRamp.stepsTimeStamps[_step] && stepFlag) {
                    text += "======== Starting step: ";
                    text += _step + 1;
                    text += ". Set Tempereture: ";
                    text += CurrentRamp.temp[_step];
                    text += "\u00B0C for ";
                    text += CurrentRamp.times[_step];
                    text += " minutes\r\n";
                    _step++;

                    if (CurrentRamp.stepsTimeStamps.length <= _step)
                    stepFlag = false;

                }
                if (GraphOptions.DataTable.getValue(i, 0).getTime() / 1000 >= CurrentRamp.end && endFlag)
                {
                    text +="========//========== Heat Ramp Ended ========//==========\r\n"
                    endFlag = false;
                }
                text += GraphOptions.DataTable.getValue(i, 1);
                text += ", ";
                text += GraphOptions.DataTable.getValue(i, 0).getTime() / 1000;
                text += ", ";
                text += delta;
                text += "\r\n";
            }
            var blob = new Blob([text], { type: "text/plain;charset=utf-8" });
            var _now = new Date(Date.now());

        }
        saveAs(blob, "HeatRampLog[" + _now.toLocaleDateString() + "].txt");

    }
}

function getnextStep(start, time) {
    return start + time * 60;
}

function ResetRoutine(params) {
    SetStopButton('Start', false);
    SetNewRampButton(true);
    currentRamp = new CurrentRampCreator();
    document.getElementById('WorkingState').style.display = 'none';
}

function stopbutton() {

    if (State.isRunning)
        RequestData('/stop');
    else
        RequestData('/start');
}

function handleHoldButton() {
    GraphOptions.holdGraph = !GraphOptions.holdGraph;
    if (GraphOptions.holdGraph) {
        document.getElementById('btnHold').className = "hold";
        // document.getElementById('btnHold').innerText="Release";
    }
    else {
        document.getElementById('btnHold').className = "";
        // document.getElementById('btnHold').innerText="Hold";

    }

    if (!GraphOptions.holdGraph)
        drawChart();
}

function sendTime() {
    var text = "settime?time=";
    text += Math.round(Date.now() / 1000);
    RequestData(text);
}

function makeTable(_selectedRow) {
    if (typeof _selectedRow === 'undefined')
    return;
    var newTable = "";
    newTable = "<tr><th>Step</th><th>Temperature (&deg;C)</th><th>Time (Mins)</th></tr>";
    for (var i = 0; i <CurrentRamp.temp.length; i++) {
       
        newTable += "<tr ";
        if(i === _selectedRow)
        newTable += "class = \"selectedRow\"";
        else if (i%2 === 0)
        newTable += "class = \"even-Row\"";
        newTable +="><td>" +  (i+1) + "</td><td>" + CurrentRamp.temp[i] + "</td><td>" + CurrentRamp.times[i] + "</td></tr>"
    }
    document.getElementById("offline-table").innerHTML = newTable;
    document.getElementById("offline-div").style.display = 'flex';

}

//##$$
        ;
}

String getPage()
{
    return
        //##$$doPage.html
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="utf-8">
    <style>
        input[type=number] {
            width: 50px;
            height: 30px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-right: 2px;
            font-size: 18px;
            text-align: center;
        }

        label {
            font-size: 18px;
        }


        .do {
            margin-left: 15%;
        }

        .boxTitle {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .Title {
            display: block;
            text-align: center;
            line-height: 150%;
            font-size: 50px;
            width: 50%;
            font-family: "Comic Sans MS";
            padding-bottom: 10px;
            color: #f52456;
            text-shadow: 2px 2px 2px 2px white;
            border: 5px solid;
            border-radius: 100px 200px;
            border-color: black;
        }

        .buttonBox {
            display: flex;
            align-items: center;
            justify-content: space-around;
            min-width: 60%;

        }

        .buttonBox .buttonBox_tn {
            height: 50px;
            border: 2px solid;
            border-radius: 10px;
            font-size: 20px;
            min-width: 100px;
            text-transform: uppercase;
        }

        .buttonBox .buttonBox_tn:hover:enabled {
            background: black;
            color: white;
            border-radius: 100px;
            width: 150px;
            transition: all 0.5s linear;
        }

        .buttonBox .bt_sub:hover:enabled {
            background: darkgreen;
            color: white;
            border-radius: 100px;
            width: 150px;
            transition: all 0.5s linear;
        }

        .h1_welcome {
            text-align: center;
            font: 24px Arial;
        }

        .infoBox {
            display: flex;
            justify-content: center;
        }

        .h1_dropdownBox {
            font: 16px Arial;
        }

        .infoBox {
            margin-left: 5%;
        }

        .infoBox .dropdownBox {
            margin-left: 10px;
            font: 20px Arial;
            align-content: center;
            align-items: center;
            text-align: center;
        }

        .bigBox {
            margin-left: 5%;
            display: flex;
            justify-content: space-evenly;
        }

        .inputBox {
            border: 1px solid;
            padding: 10px;
        }

        .preview_chart {
            min-width: 50%;
            width: 700px;
            min-height: 400px
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 23px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 17px;
            width: 17px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
        }

        input:checked+.slider {
            background-color: #2196F3;
        }

        input:focus+.slider {
            box-shadow: 0 0 1px #2196F3;
        }

        input:checked+.slider:before {
            -webkit-transform: translateX(17px);
            -ms-transform: translateX(17px);
            transform: translateX(17px);

        }

        /* Rounded sliders */
        .slider.round {
            border-radius: 23px;
        }

        .slider.round:before {
            border-radius: 50%;
        }

        .optionsBox
        {
            justify-content: space-between;
        }

    </style>
    <script>
        var currentSize = 0;
        function loadtxt() {
        }
        function generateLabel(_size) {
            var s = '<div id="div' + _size + '"><label>Temperature:</label> <input type="number" step="0.5" onchange="ManualDraw()" id="temp' + _size + '" name="temp' + _size + '" min="-55" max="85"> <label>&deg;C  </label> <label style="margin-left: 10px">Time:</label><input type="number" step="any" onchange="ManualDraw()" min="0" id="time' + _size + '" name="time' + _size + '"> <label>Mins</label><br><br></div>';
            return s;
        }
        function sizeChanged(value) {
            var newSize = parseInt(value);
            // console.log(value, currentSize, value < currentSize, value > currentSize);
            var s = "";
            //  console.log('one');
            if (newSize > currentSize) {
                //console.log('two');
                for (var i = 0; i < newSize; i++) {
                    s = s + generateLabel(i);
                }

                var temp = [];
                for (var i = 0; i < currentSize; i++) {
                    try {
                        temp[i * 2] = document.getElementById('temp' + i).value;
                        temp[i * 2 + 1] = document.getElementById('time' + i).value;
                    }
                    catch (err) {
                        temp[i * 2] = "";
                        temp[i * 2 + 1] = "";
                    }
                }

                document.getElementById('inputBox').innerHTML = s;

                for (var i = 0; i < currentSize; i++) {
                    document.getElementById('temp' + i).value = temp[i * 2];
                    document.getElementById('time' + i).value = temp[i * 2 + 1];

                }
                currentSize = newSize;
                document.getElementById('dropdownBox').value = newSize;
            }
            else if (newSize < currentSize) {
                // console.log('three');
                for (var i = currentSize - 1; i >= newSize; i--) {
                    var c = document.getElementById('div' + i);
                    c.parentNode.removeChild(c);
                }
                currentSize = newSize;
                document.getElementById('dropdownBox').value = newSize;
            }


        }
        function requestLast() {

        }
        function bodyLoadEvent() {

            var options = "";
            //generate dropdown options
            for (var i = 1; i <= 20; i++) {
                options += '<option value="' + i + '">' + i + '</option>';
            }
            document.getElementById('dropdownBox').innerHTML = options;
            sizeChanged(5);

        }
        function preventEnter(event) {
            var key = parseInt(event.keyCode);
            if (key == 13) {
                event.preventDefault();

                console.log('suppressing Enter');
            }

        }
        function go(where) {
            window.location.assign(where);
            //window.location.href(place);
        }

        window.onload = function () { bodyLoadEvent(); };

    </script>
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script type="text/javascript">
        google.charts.load('current', { 'packages': ['corechart'] }); google.charts.setOnLoadCallback(drawChart); var dataview;
        function drawChart() {
            var data = new google.visualization.DataTable();
            data.addColumn('date', 'Time');
            data.addColumn('number', 'Temperature');
            // data.addRow([new Date((Date.now())), 0]);
            var _dropdownSize = parseInt(document.getElementById('dropdownBox').value);
            var _trackTime = 0;
            for (var i = 0; i < _dropdownSize; i++) {
                var _temp = parseFloat(document.getElementById('temp' + i).value);
                var _time = parseFloat(document.getElementById('time' + i).value);
                console.log(_temp, _time);
                if (!isNaN(_temp) && !isNaN(_time)) {
                    data.addRow([new Date(Date.now() + 1000 * (_trackTime)), _temp]);
                    data.addRow([new Date(Date.now() + 1000 * (_trackTime + (60 * _time))), _temp]);
                    //data.addRow([_trackTime, _temp]);
                    //  data.addRow([_trackTime + (60 * _time), _temp]);
                    _trackTime = _trackTime + (60 * _time);
                }
            }
            dataview = data;
            var options = {
                title: 'Preview',
                backgroundColor: '#F0FFF0',
                titleTextStyle: { fontName: 'Arial', fontSize: '30', bold: 'true' },
                legend: 'none',
                curveType: 'line', animation: { startup: true, easing: 'in' },
                hAxis: { title: 'Time', format: 'HH:mm' },
                colors: ['red'],
                vAxes: {
                    0: {
                        logScale: false, maxValue: 35, minValue: 25, gridlines: { count: 5 }, title: 'Temp(\xB0C)', titleTextStyle: {
                            color: 'black',
                            fontName: 'Arial',
                            fontSize: '20'
                        }
                    },

                },
                series: {
                    0: { targetAxisIndex: 0 },
                }
            };
            var date_formatter = new google.visualization.DateFormat({
                pattern: "HH:mm:ss"
            });
            date_formatter.format(data, 0);
            var chart = new google.visualization.LineChart(document.getElementById('preview_chart'));
            chart.draw(data, options);
        }
        function ManualDraw() {
            drawChart();
        }
        function addData(time, temp, hum) {
            var data = new google.visualization.DataTable();
            data = dataview;
            data.addRow([new Date(1000 * (10800 + time)), temp, hum]);
            if (data.getNumberOfRows() > 60) {
                data.removeRow(0);
            }
            dataview = data;
            var options = {
                title: 'Live Data',
                backgroundColor: '#F0FFF0',
                titleTextStyle: { fontName: 'Arial', fontSize: '30', bold: 'true' },
                legend: 'none',
                curveType: 'function', animation: { startup: true, easing: 'in' },
                hAxis: { title: 'Time(s)', format: 'mm:ss' },
                colors: ['red', 'blue'],
                vAxes: {
                    0: {
                        logScale: false, maxValue: 35, minValue: 25, gridlines: { count: 5 }, title: 'Temp(\xB0C)', titleTextStyle: {
                            color: 'red',
                            fontName: 'Arial',
                            fontSize: '30'
                        }
                    },
                    1: {
                        logScale: false, maxValue: 100, minValue: 50, gridlines: { count: 10 }, title: 'Humidity(%)', fontName: 'Arial', titleTextStyle: {
                            color: 'blue',
                            fontName: 'Arial',
                            fontSize: '25'
                        }
                    }
                },
                series: {
                    0: { targetAxisIndex: 0 },
                    1: { targetAxisIndex: 1 },
                }
            };
            var date_formatter = new google.visualization.DateFormat({
                pattern: "HH:mm:ss"
            });
            date_formatter.format(data, 0);
            var chart = new google.visualization.LineChart(document.getElementById('curve_chart'));
            chart.draw(data, options);
        }
    </script>
</head>

<body style="background-color: #F0FFF0;">
    <div class="boxTitle">
        <label class="Title">Nova Rampa de Calor</label>
    </div>
    <div style="justify-content: center; margin-left:10%; margin-right:10%;">
        <h2 class="h1_welcome">Bem vindo a p&aacutegina de configura&ccedil;&atildeo. Configure abaixo a rampa de calor
            a ser executada.<br>Note que a atemperatura pode ser variada entre -125&deg;C e +85&deg;C por
            limita&ccedil;Ãµes do sensor</h2>
    </div>

    <form action="/do" id="doForm" method="GET" onkeypress="preventEnter(event)">
        <div class="infoBox">
            <h1 class="h1_dropdownBox">Selecione a quantidade de passos que deseja</h1>
            <select name="steps" class="dropdownBox" id="dropdownBox" onchange="sizeChanged(this.value)">
            </select>
        </div>
        <br>
        <div class="bigBox">
            <div class="inputBox" id="inputBox">
            </div>
            <div class="chartBox">
                <div class="preview_chart" id="preview_chart">
                </div>
                <!-- <div style="margin-bottom:5px; margin-left:20px; flex-direction: row; justify-content: space-evenly; display: flex;"> -->

                <div style="display: flex; flex-direction: row; justify-content: space-between">
                    <div class="buttonBox">
                        <input class="buttonBox_tn" type="button" value="Back" onclick="go('/')">
                        <!-- <input class="buttonBox_tn" type="button" disabled value="Preview" onclick="ManualDrawChart()"> -->
                        <input class="buttonBox_tn" type="button" value="Last" onclick="requestLast()">
                        <input class="buttonBox_tn bt_sub" type="submit" value="Submit">

                    </div>
                    <div class="optionsBox" style="justify-content: space-between; display: flex; flex-direction: column;">
                        <div >
                            <div style="justify-content: space-between; display: flex;">
                            <label style="margin-right: 2px">Nome do projeto: </label>
                            <input type="text" name="pname" size="10px">
                            </div>
                            <br>
                            <div style="justify-content: space-between; display: flex;">
                                <label style="margin-right: 2px">
                                    Esquentar antes de come&ccedil;ar:
                                </label>
                                <label class="switch">
                                    <input type="checkbox" name="heatup">
                                    <span class="slider round"></span>
                                </label>
                            </div>
                            <br>
                            <div style="justify-content: space-between; display: flex;">
                                <label style="margin-right: 10px">
                                    Come&ccedil;ar ap&oacute;s Salvar:
                                </label>
                                <label class="switch">
                                    <input type="checkbox" name="_start" checked on>
                                    <span class="slider round"></span>
                                </label>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
            </div>


    </form>
    <footer style="justify-content: center;">
        <p>
            <i>Supersonic by MattediWorks</i>
        </p>
    </footer>
</body>

</html>//##$$

        ;
}

//most important
void updateTemperatures()
{
    //    float _temp = 0;
    DS18.requestTemperatures();
    float _temp = DS18.getTempCByIndex(0);

    _temp = random_temp / 10;
    //ReadError
    if (_temp == -127)
        return;

    if (now() >= LastTime + sample_rate_in_seconds)
    {
        if(currentRamp.running){
        if (digitalRead(RELAY_PIN))
        random_temp = random(random_temp, random_temp + 50);
        else 
        random_temp = random(random_temp - 50, random_temp);
        }
        else
        {
             random_temp = random(random_temp - 50, random_temp +50);
        }
        
        /*String file = "";
        file += "(";
        file += LineCounter;
        file += ") - ";
        file += now();
        file += " - ";
        file += _temp;
        file += "\n";
        SD_File_Writer("/Logs/test.log", file, true);
        LineCounter++;*/
        resetFlags();
        if (is_time_configured)
        {
            if (DS18_CurrentIndex >= HISTORY_SIZE)
                DS18_CurrentIndex = 0;
            DS18Temp[DS18_CurrentIndex] = _temp;
            DS18Time[DS18_CurrentIndex] = now();
            DS18_CurrentIndex++;
        }
        LastTime = now();
        if (debug.temp)
        {
            Serial.print("current temp: ");
            Serial.print(_temp);
            Serial.println();
        }

        if (currentRamp.running)
        {
            currentRamp.csv(_temp, digitalRead(RELAY_PIN));
        }
    }

    //TODO GREENHOUSE CONTROL
    if (currentRamp.running)
    {
        if (now() >= currentRamp.StepsTimes[currentRamp.currentstep])
        {
            int timeup = millis() - oldM;
            String msg = "[";
            msg += timeup;
            msg += " ms.] ";

            currentRamp.currentstep++;
            msg += ">>> step: ";
            if (currentRamp.currentstep >= currentRamp.totalsteps)
                msg += "-";
            else
                msg += currentRamp.currentstep;
            msg += ". Time: ";
            msg += now();
            msg += ". next step: ";
            if (currentRamp.currentstep + 1 >= currentRamp.totalsteps)
                msg += "-";
            else
                msg += currentRamp.StepsTimes[currentRamp.currentstep];
            msg += "\n";
            currentRamp.log(msg);
            Serial.print(msg);
            oldM = millis();
            if (currentRamp.currentstep >= currentRamp.totalsteps)
            {
                String msg2 = "Ramp Finished. now: ";
                msg2 += now();
                msg2 += ". Step: ";
                msg2 += currentRamp.currentstep;
                msg2 += ".";
                currentRamp.log(msg);
                new_prog = true;
                currentProg = 100;
                EndRamp();
            }
            else
            {
                new_step = true;
            }
            currentRamp.csv(_temp, digitalRead(RELAY_PIN));
        }
        bool oldRelayState = digitalRead(RELAY_PIN);
       
        //Serial.print(">>>>>>");Serial.println(" _temp < currentRamp.temperatureSteps[currentRamp.currentstep] && oldRelayState");
        //High Temp
        /*
        Serial.print("old: ");
        Serial.print(oldRelayState);
        Serial.print("-t: ");
        Serial.print(_temp);
        Serial.print("-st: ");
        Serial.print( currentRamp.temperatureSteps[currentRamp.currentstep]);
         Serial.print("-ev: ");
        Serial.println(_temp < currentRamp.temperatureSteps[currentRamp.currentstep]);
*/
        if (_temp > currentRamp.temperatureSteps[currentRamp.currentstep] + tolerance && oldRelayState)
        {
            digitalWrite(RELAY_PIN, 0);
            new_relay_state = true;
            Serial.println("off");
        }
        //Low Temp
        else if (_temp < currentRamp.temperatureSteps[currentRamp.currentstep] -tolerance && !oldRelayState)
        {
            digitalWrite(RELAY_PIN, 1);
            new_relay_state = true;
            Serial.println("on");
        }

        int raw_current = now() - currentRamp.startTime;
        int raw_end = currentRamp.StepsTimes[currentRamp.totalsteps - 1] - currentRamp.startTime;
        byte new_percent = map(raw_current, 0, raw_end, 0, 100);
        //byte new_percent = map(now() - currentRamp.startTime,0,computedEnd - currentRamp.startTime,0,100);

        if (new_percent != currentProg)
        {
            // Serial.print("percent: ");
            // Serial.print(new_percent);
            if (debug.ramp)
            {
                Serial.print("percent: ");
                Serial.print(new_percent);
                Serial.print("%. curr: ");
                Serial.print(raw_current);
                Serial.print(" secs. end: ");
                Serial.print(raw_end);
                Serial.println();
            }
            new_prog = true;
            currentProg = new_percent;
        }
    }
   
    else if (currentRamp.heating)
    {
        bool oldRelayState = digitalRead(RELAY_PIN);
        if (_temp > currentRamp.temperatureSteps[0] + tolerance && oldRelayState)
        {
            digitalWrite(RELAY_PIN, 0);
            new_relay_state = true;
        }
        if (_temp < currentRamp.temperatureSteps[0] - tolerance && !oldRelayState)
        {
            digitalWrite(RELAY_PIN, 1);
            new_relay_state = true;
        }

        if (_temp >=currentRamp.temperatureSteps[0] - tolerance && _temp <= currentRamp.temperatureSteps[0] + tolerance)
        {
            currentRamp.log("Heating done. Starting ramp.");
            StartRamp();
            currentRamp.heating = false;
        }
    }
    else if (now() > ended_time + (HISTORY_SIZE * sample_rate_in_seconds))
        resetRamp();
}

void handleStart(AsyncWebServerRequest *request)
{

    if (!currentRamp.running)
        StartRamp();

    String msg = "ramp_start:";
    msg += currentRamp.startTime;
    msg += ';';
    msg += "current_state:";
    msg += "true;";
    request->send(200, "text/plain", msg);
}

void handleStop(AsyncWebServerRequest *request)
{
    if (currentRamp.running)
        EndRamp();
    String msg = "";
    request->send(200, "text/plain", msg);
}

void handleReqState(AsyncWebServerRequest *request)
{
    String msg = StateString();
    // Serial.println(msg);
    request->send(200, "text/plain", msg);
}

void handleSetTime(AsyncWebServerRequest *request)
{

    //prevents override --dont trust clients if u can trust time api
    // if(is_time_configured)
    // return;

    if (request->hasArg("time"))
    {
        Serial.print("time recieved from client: ");
        Serial.println(atoi(request->arg((size_t)0).c_str()));
        setTime(atoi(request->arg((size_t)0).c_str()));
        is_time_configured = true;
        String msg ="Time Synced ";
            msg+=  millis();
            msg+=  "ms from boot.";
            GeneralLog(msg);
              StandardTesting();
    }

    request->send(200, "text/plain", "set_time-sucess");
    return;
}

void handleWebServer(AsyncWebServerRequest *request)
{

    if (!request->authenticate(www_username, www_password))
    {
        request->requestAuthentication();
        return;
    }

    ///Check if file exists
    int a = millis();
    String filename = "/Web";
    String apiname = request->url();

    if (apiname.endsWith("/"))
        apiname += "MainPage.html";
    filename += apiname;

 
    if (debug.web)
    {
        Serial.print("filename: ");
        Serial.print(filename);
        Serial.print("  -----  apiname: ");
        Serial.println(apiname);
    
    }
    Serial.print("cache location: ");
    int cache = Cache.Contains(apiname);
    Serial.println(cache);

        if (cache >= 0)
    {
        AsyncWebServerResponse *res = request->beginResponse(200,getMIME(apiname),Cache.getPagebyIndex(cache));
        request->send(res);
        if (debug.web)
        {
            Serial.print("Service Time: ");
            Serial.print(millis() - a);
            Serial.println("ms.");
        }
        return;
    }
    if (apiname == "/requpdate")
    {
        handleRequestUpdate(request);
        return;
    }
    else if (apiname == "/reqstate")
    {

        Serial.print(millis() - a);
        Serial.println("ms.");
        return;
    }
    else if (apiname == "/reqhist")
    {
        handleRequestHist(request);
        return;
    }
    else if (apiname == "/do")
    {
        handleNewRamp(request);
        request->send(200, "text/html", "<html><script>window.location.assign(\"/\")</script></html>");
    }
    else if (apiname == "/Wifilist")
        ;
    else if (apiname == "/reqstate")
    {
        request->send(200,"text/plain",StateString());
        return;
    }
    else if (apiname == "/settime")
    {
        handleSetTime(request);
        if (debug.web)
        {
            Serial.print("Service Time: ");
            Serial.print(millis() - a);
            Serial.println("ms.");
        }
        return;
    }
    else if (apiname == "/fileslist")
    {
        request->send(200, "text/plain", listLogFiles());
        if (debug.web)
        {
            Serial.print("Service Time: ");
            Serial.print(millis() - a);
            Serial.println("ms.");
        }
        return;
    }
    else if (apiname == "/deleteFile")
    {
        String filename = "/Logs/";
        filename += request->arg("fileName");
        String Message = "";
        if (SD_MMC.exists(filename))
        {
            if (filename != "/Logs/General.log")
            {
                SD_MMC.remove(filename);
                String logMsg = "File deleted: ";
                logMsg += filename;
                logMsg += ".";
                GeneralLog(logMsg);
                Message += "delete_sucessful:";
                Message += filename;
                Message += ";";
            }
            else
            {
                Message += "error:Acess Denied.\nYou don't have permission to delete the General Log;";
            }
        }
        else
            Message += "error:File was not Found;";
        Message += listLogFiles();
        request->send(200, "text/plain", Message);
        if (debug.web)
        {
            Serial.print("Service Time: ");
            Serial.print(millis() - a);
            Serial.println("ms.");
        }
        return;
    }

    if (is_SD_Mount)
    {
        if (debug.web)
        {
            Serial.println("looking in SD Card");
        }
        if (SD_MMC.exists(filename))
        {
            File _file = SD_MMC.open(filename);
            SendLargeFiles(request, _file);
            _file.close();
            if (debug.web)
            {
                Serial.print("Service Time: ");
                Serial.print(millis() - a);
                Serial.println("ms.");
            }
            return;
        }
        else if (SD_MMC.exists(filename + ".html"))
        {
            File _file = SD_MMC.open(filename + ".html");
            SendLargeFiles(request, _file);
            _file.close();
            if (debug.web)
            {
                Serial.print("Service Time: ");
                Serial.print(millis() - a);
                Serial.println("ms.");
            }
            return;
        }
        else if (SD_MMC.exists(filename + ".css"))
        {
            File _file = SD_MMC.open(filename + ".css");
           SendLargeFiles(request, _file);
            _file.close();
            if (debug.web)
            {
                Serial.print("Service Time: ");
                Serial.print(millis() - a);
                Serial.println("ms.");
            }
            return;
        }
        else if (SD_MMC.exists(filename + ".js"))
        {
            File _file = SPIFFS.open(filename + ".js");
           SendLargeFiles(request, _file);
            _file.close();
            if (debug.web)
            {
                Serial.print("Service Time: ");
                Serial.print(millis() - a);
                Serial.println("ms.");
            }
            return;
        }
        else if (SD_MMC.exists(apiname))
        {
            File _file = SD_MMC.open(apiname);
SendLargeFiles(request, _file);
            _file.close();
            if (debug.web)
            {
                Serial.print("Service Time: ");
                Serial.print(millis() - a);
                Serial.println("ms.");
            }
            return;
        }
    }

    else if (is_SPIFFSS_Mount)
    {
        if (debug.web)
        {
            Serial.println("looking in SPIFFS");
        }

        if (SPIFFS.exists(filename))
        {
            File _file = SPIFFS.open(filename);
            request->send(200, getMIME(filename), _file.readString());
            _file.close();
            return;
        }
        else if (SPIFFS.exists(filename + ".html"))
        {
            File _file = SPIFFS.open(filename + ".html");
            request->send(200, getMIME(filename + ".html"), _file.readString());
            _file.close();
            Serial.print(millis() - a);
            Serial.println("ms.");
            return;
        }
        else if (SPIFFS.exists(filename + ".css"))
        {
            File _file = SPIFFS.open(filename + ".css");
            request->send(200, getMIME(filename + ".css"), _file.readString());
            _file.close();
            return;
        }
        else if (SPIFFS.exists(filename + ".js"))
        {
            File _file = SPIFFS.open(filename + ".js");
            request->send(200, getMIME(filename + ".js"), _file.readString());
            _file.close();
            return;
        }
    }

    String message = "File Not Found\n\n";
    message += "URI: ";
    message += request->url();
    message += "\nMethod: ";
    message += request->method();
    message += "\nArguments: ";
    message += request->args();
    message += "\n";

    for (uint8_t i = 0; i < request->args(); i++)
    {
        message += " " + request->argName(i) + ": " + request->arg(i) + "\n";
    }
    request->send(404, "text/plain", message);
    if (debug.web)
    {
        Serial.println(message);
        Serial.print("Service Time: ");
        Serial.print(millis() - a);
        Serial.println("ms.");
    }
    return;
}

class EstufaRequestHandler : public AsyncWebHandler
{
public:
    EstufaRequestHandler() {}
    virtual ~EstufaRequestHandler() {}

    bool canHandle(AsyncWebServerRequest *request)
    {
        //request->addInterestingHeader("ANY");
        return true;
    }

    void handleRequest(AsyncWebServerRequest *request)
    {
        handleWebServer(request);
    }
};

String getApAvailables()
{
    String returnmsg = "";
    byte numSsid = WiFi.scanNetworks();
    Serial.print("Number of available WiFi networks discovered:");
    Serial.println(numSsid);
    for (byte i = 0; i < numSsid; i++)
    {
        Serial.print(i);
        Serial.print(") ");
        Serial.print(WiFi.SSID(i));
        Serial.print("\tSignal: ");
        Serial.print(WiFi.RSSI(i));
        Serial.print(" dBm");
        Serial.print("\tEncryption: ");
        Serial.println(WiFi.encryptionType(i));

        returnmsg += WiFi.SSID(i);
        returnmsg += ':';
        returnmsg += WiFi.RSSI(i);
        returnmsg += ';';
    }

    return returnmsg;
}

#pragma region OTA
void startOTA()
{
    String type;
    is_updating = true;
    //caso a atualizaÃ§Ã£o esteja sendo gravada na memÃ³ria flash externa, entÃ£o informa "flash"
    SPIFFS.end();
    if (ArduinoOTA.getCommand() == 0)
        type = "flash";
    else                     //caso a atualizaÃ§Ã£o seja feita pela memÃ³ria interna (file system), entÃ£o informa "filesystem"
        type = "filesystem"; // U_SPIFFS
    //exibe mensagem junto ao tipo de gravaÃ§Ã£o
    Serial.println("Start updating " + type);
}
//exibe mensagem
void endOTA()
{
    Serial.println("\nEnd");
}
//exibe progresso em porcentagem
void progressOTA(unsigned int progress, unsigned int total)
{
    Serial.printf("Progress: %u%%\r", (progress / (total / 100)));
}

void errorOTA(ota_error_t error)
{
    Serial.printf("Error[%u]: ", error);
    if (error == OTA_AUTH_ERROR)
        Serial.println("Auth Failed");
    else if (error == OTA_BEGIN_ERROR)
        Serial.println("Begin Failed");
    else if (error == OTA_CONNECT_ERROR)
        Serial.println("Connect Failed");
    else if (error == OTA_RECEIVE_ERROR)
        Serial.println("Receive Failed");
    else if (error == OTA_END_ERROR)
        Serial.println("End Failed");
}
#pragma endregion

void listAllFiles(String dir = "/", bool SD_card = false, byte treesize = 0)
{
    ///SPIFFS mode
    if (!SD_card)
    {
        // List all available files (if any) in the SPI Flash File System
        if (!is_SPIFFSS_Mount)
        {
            Serial.print("SPIFFS not Mount");
            return;
        }
        Serial.print("Used Bytes: ");
        Serial.print(SPIFFS.usedBytes());
        Serial.print("-----Total Bytes: ");
        Serial.print(SPIFFS.totalBytes());
        Serial.print("-----Used: ");
        Serial.print(map(SPIFFS.usedBytes(), 0, SPIFFS.totalBytes(), 0, 100));
        Serial.println("%");
        Serial.print("Listing files in: ");
        Serial.println(dir);
        File root = SPIFFS.open(dir);
        File file = root.openNextFile();
        while (file)
        {
            Serial.print("FILE: ");
            Serial.print(file.path());
            Serial.print(" size: ");
            Serial.print((float)file.size() / 1024);
            Serial.println("Kb");
            file = root.openNextFile();
        }
        root.close();
        file.close();
    }
    //SD card mode
    else if (SD_card)
    {
        if (!is_SD_Mount)
        {
            Serial.print("SD card not Mount");
            return;
        }
        if (treesize == 0)
        {
            Serial.print("Used Bytes: ");
            Serial.print(SD_MMC.usedBytes());
            Serial.print("-----Total Bytes: ");
            Serial.print(SD_MMC.totalBytes());
            Serial.print("-----Used: ");
            Serial.print(map(SD_MMC.usedBytes(), 0, SD_MMC.totalBytes(), 0, 100));
            Serial.println("%");
            Serial.print("Listing files in: ");
            Serial.println(dir);
        }
        File root = SD_MMC.open(dir);
        File file = root.openNextFile();
        while (file)
        {
            for (size_t i = 0; i < treesize; i++)
            {
                Serial.print("--");
            }

            Serial.print("FILE: ");
            Serial.print(file.path());
            Serial.print(" size: ");
            Serial.print((float)file.size() / 1024);
            Serial.println("Kb");
            if (file.isDirectory())
                listAllFiles(file.path(), true, treesize + 1);
            file = root.openNextFile();
        }
        root.close();
        file.close();
    }
}

void assignValue(String variable_name, String variable_value)
{

    if (variable_name == "" || variable_name == NULL)
        return;

    if (variable_name == GET_VARIABLE_NAME(WIFI_SSID))
        WIFI_SSID = variable_value;
    if (variable_name == GET_VARIABLE_NAME(WIFI_PASSWORD))
        WIFI_PASSWORD = variable_value;
}

void parseConfig(bool fromSD = false) //Loads config.cfg from SD or SPIFFS
{
    String variable_name = "";
    String variable_value = "";
    String file;

    if (fromSD)
        ;
    else
        file = SPIFFS.open("/config.cfg").readString();
    bool name_found = false;
    for (size_t i = 0; i < file.length(); i++)
    {
        if (file[i] == ':')
        {
            if (!name_found)
            {
                Serial.print("-----EROR------- this should not happen <--- name_found is true while a ':' was found please check your config.cfg file");
            }
            name_found = true;
        }
        else if (file[i] == ';')
        {
            assignValue(variable_name, variable_value);
            variable_name = "";
            variable_value = "";
            name_found = false;
        }
        else
        {
            if (!name_found)
                variable_name += file[i];
            else
                variable_value += file[i];
        }
    }
}

void loadConfig()
{
    byte mode = 0x0;

    if (is_SPIFFSS_Mount)
    {
        if (SPIFFS.exists("/config.cfg"))
            mode = 0x02;
        else
            mode = 0x01;
    }
    if (is_SD_Mount)
    {
        if (SD_MMC.exists("/config.cfg"))
            mode += 0x20;
        else
            mode += 0x10;
    }

#ifdef DEBUGMODE

    Serial.println("----- Config loader -----");
    Serial.println("mode = 0xab || a = SPIFFS. b = SD. || 0 = not mount 1 = mount 2 = found.");
    Serial.print("#########    mode = 0x");
    if (mode < 0x10)
        Serial.print(0);
    Serial.print(mode, HEX);
    Serial.println("    #########");
    Serial.println("----- Config loader END-----");

#endif

    if (mode == 0x0)
    {
        Serial.println("SPIFFS and SD filesystems not Found.");
        return;
    }

    else if (mode == 0x21 || mode == 0x20)
    {
        Serial.println("SPIFFS config not found, loading from SD.");
        if (mode == 0x21)
        {
            Serial.println("Making a copy of SD card's one into SPIFFS");
        }

        parseConfig(true);
    }

    else if (mode == 0x22)
    {
        Serial.println("Found Config.cfg files in both SD and SPIFFS. Loading from SPIFFS");
        parseConfig(false);
    }
    else if (mode == 0x12 || mode == 0x02)
    {
        Serial.println("Found Config.cfg in SPIFFS. Loading...");
        parseConfig(false);
    }
    else if (mode == 0x11 || mode == 0x10 || mode == 0x01)
    {
        Serial.println("No Config.cfg found. Creating one...");
        if (mode == 0x11 || mode == 0x10)
        {
            SPIFFS_File_Writer("/config.cfg", saveConfigString());
        }
        else
        {
            SPIFFS_File_Writer("/config.cfg", saveConfigString());
        }
    }
}
void listDir(fs::FS &fs, const char *dirname, byte filetree = 1)
{
    if (filetree == 1)
        Serial.printf("Listing directory: %s\n", dirname);

    File root = fs.open(dirname);
    if (!root)
    {
        Serial.println("Failed to open directory");
        return;
    }
    if (!root.isDirectory())
    {
        Serial.println("Not a directory");
        return;
    }

    File file = root.openNextFile();
    while (file)
    {
        Serial.print(' ');
        for (size_t i = 0; i < filetree; i++)
        {
            Serial.print("--");
        }

        if (file.isDirectory())
        {
            Serial.print("DIR : ");
            Serial.print(file.name());
            Serial.println();
            String subdirname = dirname;
            subdirname += file.name();
            listDir(fs, subdirname.c_str(), filetree++);
        }
        else
        {
            Serial.print("FILE: ");
            Serial.print(file.name());
            Serial.print("  SIZE: ");
            Serial.print(file.size());
            Serial.println();
        }
        file = root.openNextFile();
    }

    Serial.println();
}


void StandardTesting()
{

        float temps[5] = {10,20,30,50, 158};
        float mins[5] = {1,1,1,1,1};
        String pname = "stdTest";

        currentRamp.totalsteps = 5;
        for (size_t i = 0; i < 5; i++)
        {
        currentRamp.minuteSteps[i] = mins[i];
        currentRamp.temperatureSteps[i] = temps[i];
        }
        currentRamp.projectName= pname;
        currentRamp.startLogs();
        currentRamp.configured = true;
        debug.ramp = true;
        currentRamp.heatUp =true;
        startHeating();
    

}

void setup()
{
    int oldTime = millis();
    //Initializing Arrays and Data Structs.
    for (int i = 0; i < HISTORY_SIZE; i++)
    {
        DS18Temp[i] = DS18Time[i] = 0;
    }
    currentRamp.reset();
    lastRamp.reset();
    currentRamp.print();
    Serial.begin(115200);       //Start Serial
    pinMode(RELAY_PIN, OUTPUT); //Set the Relay pin to output
    //Start SPIFFS

    if (!SPIFFS.begin(true)) //Start SPIFFS
    {
        Serial.println("Error initializing SPIFFS");
        is_SPIFFSS_Mount = false;
    }
    else
    {
        Serial.print("SPIFFS Card mounted. Size: ");
        Serial.print(SPIFFS.totalBytes() / 1024);
        Serial.print("kb.  Used: ");
        Serial.print((SPIFFS.totalBytes() - SPIFFS.usedBytes()) / SPIFFS.totalBytes() * 100);
        Serial.println("%");
        is_SPIFFSS_Mount = true;
    }
    //Start SD Card
    
    if (!SD_MMC.begin("/sdcard",true, false))
    {
        Serial.println("Error initializing SD");
        is_SD_Mount = false;
    }
    else
    {
        is_SD_Mount = true;
        Serial.print("SD Card mounted. Size: ");
        Serial.print(SD_MMC.cardSize() / 1024 / 1024);
        Serial.print("Mb.  Used: ");
        Serial.print((SD_MMC.totalBytes() - SD_MMC.usedBytes()) / SD_MMC.totalBytes() * 100);
        Serial.println("%");
    }

    SD_File_Writer("/Web/doPage.html", getPage());
    SD_File_Writer("/Web/CommonScript.js", getPage2());

    WiFi.mode(WIFI_STA); //WiFi Station Mode
    WiFi.begin(WIFI_SSID.c_str(), WIFI_PASSWORD.c_str());

    bool createAp = false;

    bool beauty = true;
    while (WiFi.status() != WL_CONNECTED && !createAp)
    {
        if (millis() % 100 == 0 && beauty)
        {
            Serial.print(".");
            beauty = false;
        }
        else if (millis() % 100 != 0)
        {
            beauty = true;
        }

        if (millis() - oldTime > 14999)
        {
            Serial.printf("\nNetwork '%s' not found.\n", WIFI_SSID);
            createAp = true;
        }
    }

    if (createAp)
    {
        WiFi.mode(WIFI_AP_STA);
        WiFi.softAP(WIFI_AP_SSID, WIFI_AP_PASSWORD);
        // dnsServer.start(53, "*", WiFi.softAPIP());
        Serial.println("");
        Serial.print("Creating WiFi Ap.SSID:  ");
        Serial.println(WIFI_AP_SSID);
        Serial.print("IP address: ");
        Serial.println(WiFi.softAPIP());
    }
    else
    {

        Serial.println();
        Serial.print("Connected to ");
        Serial.println(WIFI_SSID);
        Serial.print("IP address: ");
        Serial.println(WiFi.localIP());
    }

    // server.on("/", handleRoot);
    // server.onNotFound(handleWebServer);
    // server.on("/doPage", handleDoPage);
    // server.on("/do", handleNewRamp);

    // server.on("/Common.css", handleCSS);
    // server.on("/requpdate", handleRequestUpdate);
    // server.on("/reqhist", handleRequestHist);
    // server.on("/CommonScript.js", handleCommonJs);
    // server.on("/FileSaver.js", handleFileSaverjs);
    // server.on("/favicon.ico", handlefav);
    // server.on("/reqstate", handleReqState);
    // server.on("/start", handleStart);
    // server.on("/stop", handleStop);
    // server.on("/settime", handleSetTime);

    // server.addHandler(new CaptiveRequestHandler()).setFilter(ON_AP_FILTER); //only when requested from AP
    //more handlers...server.begin();

    //Start HTTP Server
    server.addHandler(new EstufaRequestHandler()).setFilter(ON_STA_FILTER);

    if (MDNS.begin(DNS_NAME)) //DNS_NAME.local/
    {
        Serial.println("MDNS responder started");
    }

    // ArduinoOTA.setPassword("admin");
    // Password can be set with it's md5 value as well
    // MD5(admin) = 21232f297a57a5a743894a0e4a801fc3
    // ArduinoOTA.setPasswordHash("21232f297a57a5a743894a0e4a801fc3");
    // ArduinoOTA.setHostname("ESTUFA");
    ArduinoOTA.onStart(startOTA);
    ArduinoOTA.onEnd(endOTA);
    ArduinoOTA.onProgress(progressOTA);
    ArduinoOTA.onError(errorOTA);
    ArduinoOTA.begin();

    GeneralLog("Booted");
    getTime();
    DS18.begin();

    server.begin();
    Serial.println("HTTP server started");
    Serial.print("Setup done. time: ");
    Serial.print(millis() - oldTime);
    Serial.println("ms");

    Cache.setup();
    Cache.LoadPage("/FileSaver.js", "/Web/FileSaver.js");
    Cache.LoadPage("/doPage.html", "/Web/doPage.html");
    Cache.LoadPage("/MainPage", "/Web/MainPage.html");
    Cache.LoadPage("/Common.css", "/Web/Common.css");
           

    



    // Serial.println(listLogFiles());
    //listAllFiles("/", true);

}

void loop()
{
    //  int time = millis();
    ArduinoOTA.handle();
    // request->handleClient();
    updateTemperatures();
    // Serial.print("run time: ");
    // Serial.print(millis() - time);
    // Serial.println("ms");
    if (Serial.available())
    {
        String s = "";
        while (Serial.available() > 0)
        {
            char c = Serial.read();
            if (c != 10 && c != 13)
            {
                s += c;

                //Serial.print((int)c);
                //Serial.print('.');
            }
        }
        if (s != "")
        {
            Serial.print(">");
            Serial.println(s);
        }
        if (s == "web")
        {
            listDir(SD_MMC, "/Web");
        }
        else if (s == "debug web")
        {
            debug.web = !debug.web;
            Serial.print("Debug Web is now: ");
            Serial.println(debug.web);
        }
        else if (s == "debug ramp")
        {
            debug.ramp = !debug.ramp;
            Serial.print("Debug ramp is now: ");
            Serial.println(debug.ramp);
        }
        else if (s == "debug temp")
        {
            debug.temp = !debug.temp;
            Serial.print("Debug temp is now: ");
            Serial.println(debug.temp);
        }
        else if (s == "debug log")
        {
            debug.log = !debug.log;
            Serial.print("Debug log is now: ");
            Serial.println(debug.log);
        }
        else if (s == "heatramp")
        {
            currentRamp.print();
        }
        else if (s == "mem")
        {
            int mem = ESP.getFreeHeap();
            Serial.print("Free Heap: ");
            Serial.print(mem / 1024);
            Serial.println("kb.");
        }
         else if (s == "cache")
        {
            for (size_t i = 0; i < MAX_CACHE_PAGES; i++)
            {
                Serial.print("(");
                Serial.print(i);
                Serial.print(") Key: ");
                Serial.print( Cache.Keys[i]);
                Serial.println(".   Page:");
                Serial.println("----------");
                Serial.println(Cache.CachedPages[i]);
                Serial.println("----------");
            }
            
        }
        else if (SD_MMC.exists(s))
        {
            Serial.print("FILE: ");
            Serial.println(s);
            Serial.println("-------------");
            if (SD_MMC.open(s).isDirectory())
                listAllFiles(s, true);
            else
                Serial.println(SD_MMC.open(s).readString());
            Serial.println("-------------");
        }
    }
}